http://wangdoc.com/javascript/stdlib/regexp.html

## 正则表达式 是什么？
是一种表达文本模式（即字符串结构）的方法，常常用来按照给定模式匹配文本。比如正则表达式给出一个 email 地址的模式，用来确定一个字符串是否为 email 地址。

比如你写一个正则表达式，匹配出所有美女。

## 新建正则表达式的方法

- 字面量形式
```
var regex = /xyz/
```

- RegExp 构造函数
```
var regex = new RegExp('xyz')
```

- 两种方法的区别：字面量形式，在引擎编译时就会新建正则；构造函数的形式在运行时新建正则。所以，前者的效率较高，一般使用前者的形式。

## 实例属性

**修饰符相关的属性，皆只读**
- ignoreCase 返回布尔值，表示是否设置了 i 修饰符。
- global ...g 修饰符。
- multiline ...m 修饰符
- flags 返回字符串，包含了已经设置的所有修饰符，按字母排序。

```
var r = /abc/igm
r.ignoreCase  // true
r.global  // true
r.multiline //true
r.flags // 'gim'
```

**其他实例属性**
- lastIndex 返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义。
- source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。
```
var r = /abc/igm

r.lastindex // 0
r.source  // "abc"
```

## 实例方法

### test() 方法
正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。

```
/cat/.test('cats and dogs')   // true
```

如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。

```
var r = /x/g

var s = '_x_x'

r.test(s) // true
```
r 带有 g 修饰符，可以一直往下匹配。此时可以试试 lastIndex 属性，看一下下一次匹配的位置。也就是说，正则内部会记住上一次 lastIndex 的值，所以，不要临时更换所要匹配的字符串。(lastIndex 只对同一个正则表达式有效)。

注意，当匹配多次匹配到字符串末尾，lastIndex 属性就自动设为 0 了。

**如果正则模式是一个空字符串，则匹配所有字符串**
```
new RegExp('').test('abc')  // true
```

### exec() 方法
把匹配成功的结果组成数组返回，不匹配则返回 null.

```
// 例1
var r = /x/
var s = '_x_x'

r.exec(s)   // ["x", index: 1, input: "_x_x", groups: undefined]

// 例2
var s = '_x_x'
var r = /_(x)/

r.exec(s)   // // ["_x", "x"]
```

正则实例对象的lastIndex属性不仅可读，还可写。设置了g修饰符的时候，只要手动设置了lastIndex的值，就会从指定位置开始匹配。

看代码
```
var reg  =/a/g;

var str= 'abc_abc_abc';

while(true){
    var match = reg.exec(str)
    if(!match) break
    console.log('#'+match.index+' : '+match[0])
}

#0 : a
#4 : a
#8 : a
```

## 字符串的实例方法
- String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。
- String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
- String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。
- String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

```
var r = /x/;

var s = 'xx_xx_xx';

s.match(r)

s.search('x')

s.replace(/x/g, 'h')
```

**以下，s 是字符串，r 是正则**
- match s.match(r) 匹配成功，返回一个数组，匹配失败返回 null，跟 exec() 方法很像。

注意：如果正则带有 g 修饰符，与exec()不同的是，match 方法会返回所有匹配的结果
```
var s = 'abba'
var r = /a/g

s.match(r)  // [a,a]
```

注意：设置正则 lastIndex 属性对 match 方法无效。match 方法总是从第一个字符开始匹配。

- 字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。
```
var s = 'abba'
var r = /a/

s.search(r) // 0
```

- 字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。正则表达式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。
```
var s = 'abba'
var r = /a/

s.replace(r, 'k')
```

- 去掉字符串收尾两端的空格
```
var s = '   adfj   ';
var r = /^\s+|\s+$/g;

s.replace(r,'')
```
**$ 符号相关**
$&：匹配的子字符串。
$`：匹配结果前面的文本。
$'：匹配结果后面的文本。
$n：匹配成功的第n组内容，n是从1开始的自然数。
$$：指代美元符号$。
```
var s = 'janson'

s.replace('a', '-$\'-$&-$`-')
// "j-nson-a-j-nson"
```

- replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。

### 字面量字符与元字符

- 大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”。

- 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。

1. 点字符 .
匹配除了回车、换行、行分隔符、段分隔符以外的所有字符。注意，对于码点大于0xFFFF字符，点字符不能正确匹配，会认为这是两个字符。

2. 位置字符
^ 表示字符串的开始位置；$ 表示字符串的结束位置。
```
/^test/.test('test9999')    // true. test 必须出现在字符串的开始位置

/test$/.test('asdftest')    // true  test 必须出现在字符串的结束位置

/^test$/.test('test test')  // false 从开始位置到结束位置只能有 test
```

3. | 就是一竖，在正则中表示或关系（or）。
```
/11|22/.test('911')     // true

// 注意，上面的选择符两边不能有空格，否则为false。因为一个空格也表示一个需要匹配的字符。
```

另，选择符包含它前后的多个字符。比如，/abc|ggg/ 匹配的是 abc 或 ggg，而不是 c 或 g。
```
/a( |\t)b/.test('a b')  // true 表示匹配 ab 之间有一个空格或制表符。
```

4. \ 转义符
正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配+，就要写成\+。
```
/1+1/.test('1+1')   // false
/1\+1/.test('1+1')  // true
```

正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。
```
(new RegExp('1\+1')).test('1+1')    // false
(new RegExp('1\\+1')).test('1+1')   // true
```

5. 字符类
字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。
```
/[abc]/.test('hello world')     // false
/[abc]/.test('apple')           // true
```

注意，有两个字符（脱字符^和连字符-）在字符类中有特殊含义。

- 脱字符 ^
如果方括号的第一个字符是脱字符^, 那么除了方括号的字符外，其他字符都能匹配。就是排除方括号内的字符嘛，简单。
```
/[^abc]/.test('hhh')    // true 因为'hhh'包含abc以外的三个字符，所以返回true
/[^abc]/.test('auuuuuu')    // true
/[^abc]/.test('bbc')    // false 因为'bbc'不包含abc以外的三个字符，所以 false
```

如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。

注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。

- 连字符 - 
某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。

另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是[A-z]，表面上它是选中从大写的A到小写的z之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果

### 预定义模式：某些常见模式的简写方式
\d 匹配 0-9 之间的任一数字，相当于 [0-9]
\D 匹配 0-9 以外的字符，相当于 [^0-9]
\w 匹配任意的字母、数字、下划线，相当于 [a-zA-Z_]
\W 匹配除了所有字母、数字、下划线，相当于 [^a-zA-Z0-9_]
\s 匹配空格，包括换行符、制表符、空格符等。相当于 [\t\r\n\v\f]
\S 匹配非空格的字符，相当于[^\t\r\n\v\f]
\b 匹配词的边界
\B 匹配非词边界，即在词的内部

- 重复类：模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。
```
/lo{2}k/.test('look')
/(lo){2}k/.test('lolok')
```

- 量词符：？表示某个模式出现0或1次，相当于 {0,1}; * 表示某个模式出现0或多次，相当于 {0,} ; + 表示某个模式出现1或多次，相当于 {1,} 。注意，这三个量词符都是最大可能匹配。

### 贪婪模式
默认情况下最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。
```
/a+/.exec('aaaa')   // ["aaaa", index: 0, input: "aaaa", groups: undefined]

// + 表示匹配一个或多个，那到底匹配几个呢？由于是贪婪模式，所以，会匹配最大可能数量。
```

**如何改贪婪模式为非贪婪模式？**
在后面加一个问好。
```
var s = 'aaa'

s.match(/a+?/)  // ["a"]  一旦条件满足就不再往下匹配了。

'abb'.match(/ab*b/)    // ["abb"]

'abb'.match(/ab*?b/)   // ["ab"]

'abb'.match(/ab?b/)    // ["abb"]

'abb'.match(/ab??b/)   // ["ab"] 
```

### 修饰符
表示模式的附加规则，放在正则的尾部。
```
var regex = /test/i
var regex = /test/ig
```

- g 修饰符
默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。

- i 修饰符
正常情况下，正则对象区分字母的大小写。加上 i 就忽略大小写了。

- m 修饰符
m 修饰符会改变 ^ $ 的行为。加了 m 修饰符后，^ $ 会识别行首和行尾，即 ^ $ 会识别换行符\n
```
/world$/.test('hello world\n')  // false
/world$/m.test('hello world\n') // true

/^b/m.test('a\nbii')    // true
```


### 组匹配
正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。
```
/(fred)+/.test('fredd')     // true
/(fred)+/.test('fredfred')      // true
```

正则表达式内部，还可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。
```
/(.)b(.)\1b\2/.test('abcabc')       // true
/y(..)(.)\2\1/.test('yabccab')  // true
/y((..)\2)\1/.test('yababababa')
```

**非捕获组**
(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。

简单理解：加了括号，就会匹配出括号内的内容，如果我不想要输出括号内的内容，我就用 (?:x) 非捕获组的用法。
```
var m = 'abc'.match(/(?:.)b(.)/)
m   // ["abc", "c"]

// 由于用了非捕获组，所以 a 不会单独成为返回数组的内容。与之对比的是，c 单独是数组的内容，因为第二组匹配不是非捕获组。
```

#### 先行断言
x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。

“先行断言”中，括号里的部分是不会返回的。
```
var m = 'abc'.match(/b(?=c)/)
m   //["b"]

注意，括号内不会被返回。
```

#### 先行否定断言
x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。
```
/\d+(?!\.)/.exec('3.14')

// 不在 . 点号前面的数字才匹配。同样，括号里的部分是不会返回的。
```

#### 写一个去掉字符串收尾空格的函数
```
// 写法一
function trim(str){
    return str.match(/([^ ])+/)[0]
}

// 写法二
function trim(str){
    return str.replace(/\s/, '')
}

// 写法三
function trim(str){
    return /(\S)+/.exec(str)[0]
}
```